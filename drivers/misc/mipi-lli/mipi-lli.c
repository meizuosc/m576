/*
 * MIPI-LLI driver
 *
 * Copyright (C) 2013 Samsung Electronics Co.Ltd
 * Author: Yulgon Kim <yulgon.kim@samsung.com>
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/err.h>
#include <linux/init.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/module.h>
#include <linux/miscdevice.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/sysfs.h>
#include <linux/kthread.h>
#include <linux/wait.h>
#include <linux/dma-mapping.h>
#include <linux/mm.h>
#include <linux/gpio.h>
#include <linux/vmalloc.h>
#include <linux/of_reserved_mem.h>
#include <linux/mipi-lli.h>

static struct mipi_lli *g_lli;
phys_addr_t lli_phys_addr;

/**
 * mipi_lli_request_sh_region
 * @sh_addr: shared physical address
 * @size: allocation region size
 *
 * Returns a pointer to the allocated shared memory buffer address.
 */
void __iomem *mipi_lli_request_sh_region(unsigned long sh_addr,
					unsigned long size)
{
	if (!g_lli)
		return NULL;
	return (void __iomem *)g_lli->shdmem_addr;
}
EXPORT_SYMBOL(mipi_lli_request_sh_region);

/**
 * mipi_lli_release_sh_region
 * @rgn: request memory region
 */
void mipi_lli_release_sh_region(void *rgn)
{
	return;
}
EXPORT_SYMBOL(mipi_lli_release_sh_region);

/**
 * mipi_lli_get_phys_base
 *
 * Returns physical base address.
 */
phys_addr_t mipi_lli_get_phys_base(void)
{
	return g_lli->phys_addr;
}
EXPORT_SYMBOL(mipi_lli_get_phys_base);

/**
 * mipi_lli_release_sh_region
 *
 * Returns phys address size.
 */
unsigned long mipi_lli_get_phys_size(void)
{
	return g_lli->shdmem_size;
}
EXPORT_SYMBOL(mipi_lli_get_phys_size);

/**
 * mipi_lli_suspended
 *
 * Returns mipi_lli_is_suspended.
 */
int mipi_lli_suspended(void)
{
	return g_lli->is_suspended;
}
EXPORT_SYMBOL(mipi_lli_suspended);

/**
 * mipi_lli_get_link_status
 *
 * Returns mipi_lli_link_status.
 */
int mipi_lli_get_link_status(void)
{
	return atomic_read(&g_lli->state);
}
EXPORT_SYMBOL(mipi_lli_get_link_status);

/**
 * mipi_lli_get_link_status
 *
 * Returns mipi_lli_link_status.
 */
int mipi_lli_set_link_status(int state)
{
	atomic_set(&g_lli->state, state);
	if (atomic_read(&g_lli->state) == LLI_WAITFORMOUNT)
		g_lli->hd.handler(g_lli->hd.data, LLI_EVENT_WAITFORMOUNT, 0);

	return 0;
}
EXPORT_SYMBOL(mipi_lli_set_link_status);

/**
 * mipi_lli_register_handler
 * @handler: callback function when signal interrupt is occured.
 * @data: parameter when handler is callbacked.
 *
 * Returns 0 on success
 * otherwise ERR_PTR(errno).
 */
int mipi_lli_register_handler(void (*handler)(void *, enum mipi_lli_event, u32),
		void *data)
{
	if (!handler)
		return -EINVAL;

	/* Register interrupt handler */
	g_lli->hd.data = data;
	g_lli->hd.handler = handler;

	return 0;
}
EXPORT_SYMBOL(mipi_lli_register_handler);

/**
 * mipi_lli_unregister_handler
 * @handler: callback function when signal interrupt is occured.
 *
 * Returns 0 on success
 * otherwise ERR_PTR(errno).
 */
int mipi_lli_unregister_handler(void (*handler)(void *, enum mipi_lli_event,
			u32))
{
	if (!handler || (g_lli->hd.handler != handler))
		return -EINVAL;

	/* Unregister interrupt handler */
	g_lli->hd.data = NULL;
	g_lli->hd.handler = NULL;

	return 0;
}
EXPORT_SYMBOL(mipi_lli_unregister_handler);

/**
 * mipi_lli_send_interrupt - sending sideband signal.
 * @cmd: Send interrupt command
 */
void mipi_lli_send_interrupt(u32 cmd)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->send_signal)
		return;

	g_lli->driver->send_signal(g_lli, cmd);
}
EXPORT_SYMBOL(mipi_lli_send_interrupt);

/**
 * mipi_lli_reset_interrupt - Clear all sideband signal.
 */
void mipi_lli_reset_interrupt(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->reset_signal)
		return;

	g_lli->driver->reset_signal(g_lli);
}
EXPORT_SYMBOL(mipi_lli_reset_interrupt);

/**
 * mipi_lli_read_interrupt - reading sideband signal.
 *
 * Returns a sideband signal bit that generated by CP.
 */
u32 mipi_lli_read_interrupt(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->read_signal)
		return 0;

	return g_lli->driver->read_signal(g_lli);
}
EXPORT_SYMBOL(mipi_lli_read_interrupt);

/**
 * mipi_lli_debug_info - Print debugging information for LLI.
 */
void mipi_lli_debug_info(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->debug_info)
		return;

	g_lli->driver->debug_info(g_lli);
}
EXPORT_SYMBOL(mipi_lli_debug_info);

/**
 * mipi_lli_reset - Reset all resource for the first mount
 *
 * Returns a pointer to the allocated event buffer structure on success
 * otherwise ERR_PTR(errno).
 */
void mipi_lli_reset(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->init)
		return;

	g_lli->driver->init(g_lli);
	//atomic_set(&g_lli->mnt_cnt, 0);
}
EXPORT_SYMBOL(mipi_lli_reset);

/**
 * mipi_lli_reload - Reload all resource for re-init
 *
 * Returns a pointer to the allocated event buffer structure on success
 * otherwise ERR_PTR(errno).
 */
void mipi_lli_reload(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->init)
		return;

	g_lli->driver->init(g_lli);
}
EXPORT_SYMBOL(mipi_lli_reload);

static void __maybe_unused mipi_lli_send_signal_test(struct mipi_lli *lli)
{
	u32 i;

	for (i = 0; i < 32; i++)
		lli->driver->send_signal(g_lli, (1 << i));
}

static ssize_t show_mipi_lli_control(struct device *dev,
			       struct device_attribute *attr,
			       char *buf)
{
#ifndef CONFIG_LINK_DEVICE_LLI
	struct mipi_lli *lli = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "MIPI-LLI %x\n",
			lli->driver->get_status(lli));
#else
	return snprintf(buf,PAGE_SIZE, "Cannot support sysfs interface\n");
#endif
}

static ssize_t store_mipi_lli_control(struct device *dev,
				struct device_attribute *attr,
				const char *buf, size_t count)
{
#ifndef CONFIG_LINK_DEVICE_LLI
	struct mipi_lli *lli = dev_get_drvdata(dev);
	int command;

	if (sscanf(buf, "%10d", &command) != 1)
		return -EINVAL;

	device_lock(dev);

	if (command == 0)
		lli->driver->debug_info(lli);
	else if (command == 1)
		lli->driver->init(lli);
	else if (command == 2)
		lli->driver->set_master(lli, true);
	else if (command == 3)
		lli->driver->link_startup_mount(lli);
	else if (command == 4)
		lli->driver->exit(lli);
	else if (command == 5)
		mipi_lli_send_signal_test(lli);
	else if (command == 6)
		lli->driver->loopback_test(lli);
	else if (command == 98)
		print_hex_dump(KERN_INFO, "llimem: ", DUMP_PREFIX_OFFSET, 16, 1,
				g_lli->shdmem_addr + SZ_1K, 512, true);
	else if (command == 99)
		print_hex_dump(KERN_INFO, "llimem: ", DUMP_PREFIX_OFFSET, 16, 1,
				g_lli->shdmem_addr + SZ_1K + 512, 512, true);
	else
		dev_err(dev, "Un-support control command\n");

	device_unlock(dev);
#else
	dev_err(dev, "Cannot support sysfs interface\n");
#endif
	return count;
}
static DEVICE_ATTR(lli_control, 0644,
	show_mipi_lli_control, store_mipi_lli_control);

static irqreturn_t mipi_lli_sig_irq(int irq, void *_dev)
{
	struct mipi_lli *lli = _dev;
	u32 intr = 0;

	if (lli->driver->read_signal)
		intr = lli->driver->read_signal(lli);

	if (g_lli->hd.handler)
		g_lli->hd.handler(g_lli->hd.data, LLI_EVENT_SIG, intr);

	return IRQ_HANDLED;
}

int mipi_lli_event_irq(struct mipi_lli *lli, enum mipi_lli_event event)
{
	if (!lli || !lli->hd.handler)
		return -EINVAL;

	lli->hd.handler(lli->hd.data, event, 0);

	return 0;
}

/**
 * mipi_lli_intr_enable
 */
void mipi_lli_intr_enable(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->suspend)
		return;

	g_lli->driver->intr_enable(g_lli);
}
EXPORT_SYMBOL(mipi_lli_intr_enable);

/**
 * mipi_lli_intr_disable
 */
void mipi_lli_intr_disable(void)
{
               if (!g_lli || !g_lli->driver || !g_lli->driver->intr_disable)
                               return;

               g_lli->driver->intr_disable(g_lli);
}
EXPORT_SYMBOL(mipi_lli_intr_disable);

/**
 * mipi_lli_suspend must call by modem_if.
 */
void mipi_lli_suspend(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->suspend)
		return;

	g_lli->driver->suspend(g_lli);
}
EXPORT_SYMBOL(mipi_lli_suspend);

/**
 * mipi_lli_resume must call by modem_if.
 */
void mipi_lli_resume(void)
{
	if (!g_lli || !g_lli->driver || !g_lli->driver->resume)
		return;

	g_lli->driver->resume(g_lli);
}

EXPORT_SYMBOL(mipi_lli_resume);

void __iomem *mipi_lli_vmap(phys_addr_t phys_addr, phys_addr_t size)
{
	int i;
	struct page **pages;
	unsigned int num_pages = (unsigned int)(size >> PAGE_SHIFT);
	void *pv;

	pages = kmalloc(num_pages * sizeof(*pages), GFP_KERNEL);
	if (!pages)
		return NULL;

	for (i = 0; i < num_pages; i++) {
		pages[i] = phys_to_page(phys_addr);
		phys_addr += PAGE_SIZE;
	}

	pv = vmap(pages, num_pages, VM_MAP, pgprot_writecombine(PAGE_KERNEL));
	kfree(pages);

	return (void __iomem *)pv;
}

static void mipi_lli_rmem_device_init(struct reserved_mem *rmem,
						struct device *dev)
{
	dev_set_drvdata(dev, rmem);

	dev_info(dev, "reserved memory: %s=%#lx@%pa\n",
			rmem->name, (unsigned long) rmem->size, &rmem->base);
}

static const struct reserved_mem_ops mipi_lli_rmem_ops = {
	.device_init	= mipi_lli_rmem_device_init,
};

static int __init mipi_lli_reserved_mem_setup(struct reserved_mem *rmem)
{
	rmem->ops = &mipi_lli_rmem_ops;

	lli_phys_addr = rmem->base;

	return 0;
}

RESERVEDMEM_OF_DECLARE(mipi_lli, "mipi-lli-shmem", mipi_lli_reserved_mem_setup);

int mipi_lli_add_driver(struct device *dev,
			const struct lli_driver *lli_driver,
			int irq)
{
	struct mipi_lli *lli;
	struct reserved_mem *lli_rmem;
	int ret;

	if (g_lli)
		return 0;

	lli = devm_kzalloc(dev, sizeof(*lli), GFP_KERNEL);

	if (!lli)
		return -ENOMEM;

	lli->driver = lli_driver;
	lli->dev = dev;
	lli->irq_sig = irq;

	ret = request_irq(irq, mipi_lli_sig_irq, 0, dev_name(dev), lli);
	if (ret < 0)
		return ret;

	lli_rmem = dev_get_drvdata(dev);
	if (!lli_rmem) {
		dev_err(dev, "phys_addr was not reserved by memblock\n");
		return -ENOMEM;
	}

	lli->phys_addr = lli_rmem->base;
	lli->shdmem_addr = mipi_lli_vmap(lli_rmem->base, lli_rmem->size);

	if (!lli->shdmem_addr)
		return -ENOMEM;

	lli->shdmem_size = lli_rmem->size;

	dev_info(dev, "alloc share IPC memory addr = %p[%pa]\n",
		 lli->shdmem_addr,
		 &lli->phys_addr);

	dev_set_drvdata(dev, lli);
	g_lli = lli;

	device_create_file(dev, &dev_attr_lli_control);

	return 0;
}
EXPORT_SYMBOL(mipi_lli_add_driver);

void mipi_lli_remove_driver(struct mipi_lli *lli)
{
	free_irq(lli->irq_sig, lli);
	vunmap(lli->shdmem_addr);

	g_lli = NULL;
}
EXPORT_SYMBOL(mipi_lli_remove_driver);

MODULE_DESCRIPTION("MIPI LLI driver");
MODULE_AUTHOR("Yulgon Kim <yulgon.kim@samsung.com>");
MODULE_LICENSE("GPL");
